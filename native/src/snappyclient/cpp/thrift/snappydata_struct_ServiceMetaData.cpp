/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "snappydata_struct_ServiceMetaData.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace io { namespace snappydata { namespace thrift {


ServiceMetaData::~ServiceMetaData() noexcept {
}


void ServiceMetaData::__set_productName(const std::string& val) {
  this->productName = val;
}

void ServiceMetaData::__set_productVersion(const std::string& val) {
  this->productVersion = val;
}

void ServiceMetaData::__set_productMajorVersion(const int32_t val) {
  this->productMajorVersion = val;
}

void ServiceMetaData::__set_productMinorVersion(const int32_t val) {
  this->productMinorVersion = val;
}

void ServiceMetaData::__set_jdbcMajorVersion(const int32_t val) {
  this->jdbcMajorVersion = val;
}

void ServiceMetaData::__set_jdbcMinorVersion(const int32_t val) {
  this->jdbcMinorVersion = val;
}

void ServiceMetaData::__set_identifierQuote(const std::string& val) {
  this->identifierQuote = val;
}

void ServiceMetaData::__set_sqlKeywords(const std::vector<std::string> & val) {
  this->sqlKeywords = val;
}

void ServiceMetaData::__set_numericFunctions(const std::vector<std::string> & val) {
  this->numericFunctions = val;
}

void ServiceMetaData::__set_stringFunctions(const std::vector<std::string> & val) {
  this->stringFunctions = val;
}

void ServiceMetaData::__set_systemFunctions(const std::vector<std::string> & val) {
  this->systemFunctions = val;
}

void ServiceMetaData::__set_dateTimeFunctions(const std::vector<std::string> & val) {
  this->dateTimeFunctions = val;
}

void ServiceMetaData::__set_searchStringEscape(const std::string& val) {
  this->searchStringEscape = val;
}

void ServiceMetaData::__set_extraNameCharacters(const std::string& val) {
  this->extraNameCharacters = val;
__isset.extraNameCharacters = true;
}

void ServiceMetaData::__set_supportedCONVERT(const std::map<SnappyType::type, std::set<SnappyType::type> > & val) {
  this->supportedCONVERT = val;
}

void ServiceMetaData::__set_schemaTerm(const std::string& val) {
  this->schemaTerm = val;
}

void ServiceMetaData::__set_procedureTerm(const std::string& val) {
  this->procedureTerm = val;
}

void ServiceMetaData::__set_catalogTerm(const std::string& val) {
  this->catalogTerm = val;
}

void ServiceMetaData::__set_catalogSeparator(const std::string& val) {
  this->catalogSeparator = val;
}

void ServiceMetaData::__set_maxBinaryLiteralLength(const int32_t val) {
  this->maxBinaryLiteralLength = val;
}

void ServiceMetaData::__set_maxCharLiteralLength(const int32_t val) {
  this->maxCharLiteralLength = val;
}

void ServiceMetaData::__set_maxColumnsInGroupBy(const int32_t val) {
  this->maxColumnsInGroupBy = val;
}

void ServiceMetaData::__set_maxColumnsInIndex(const int32_t val) {
  this->maxColumnsInIndex = val;
}

void ServiceMetaData::__set_maxColumnsInOrderBy(const int32_t val) {
  this->maxColumnsInOrderBy = val;
}

void ServiceMetaData::__set_maxColumnsInSelect(const int32_t val) {
  this->maxColumnsInSelect = val;
}

void ServiceMetaData::__set_maxColumnsInTable(const int32_t val) {
  this->maxColumnsInTable = val;
}

void ServiceMetaData::__set_maxConnections(const int32_t val) {
  this->maxConnections = val;
}

void ServiceMetaData::__set_maxIndexLength(const int32_t val) {
  this->maxIndexLength = val;
}

void ServiceMetaData::__set_maxRowSize(const int32_t val) {
  this->maxRowSize = val;
}

void ServiceMetaData::__set_maxStatementLength(const int32_t val) {
  this->maxStatementLength = val;
}

void ServiceMetaData::__set_maxOpenStatements(const int32_t val) {
  this->maxOpenStatements = val;
}

void ServiceMetaData::__set_maxTableNamesInSelect(const int32_t val) {
  this->maxTableNamesInSelect = val;
}

void ServiceMetaData::__set_maxColumnNameLength(const int32_t val) {
  this->maxColumnNameLength = val;
}

void ServiceMetaData::__set_maxCursorNameLength(const int32_t val) {
  this->maxCursorNameLength = val;
}

void ServiceMetaData::__set_maxSchemaNameLength(const int32_t val) {
  this->maxSchemaNameLength = val;
}

void ServiceMetaData::__set_maxProcedureNameLength(const int32_t val) {
  this->maxProcedureNameLength = val;
}

void ServiceMetaData::__set_maxCatalogNameLength(const int32_t val) {
  this->maxCatalogNameLength = val;
}

void ServiceMetaData::__set_maxTableNameLength(const int32_t val) {
  this->maxTableNameLength = val;
}

void ServiceMetaData::__set_maxUserNameLength(const int32_t val) {
  this->maxUserNameLength = val;
}

void ServiceMetaData::__set_defaultTransactionIsolation(const int32_t val) {
  this->defaultTransactionIsolation = val;
}

void ServiceMetaData::__set_defaultResultSetType(const int8_t val) {
  this->defaultResultSetType = val;
}

void ServiceMetaData::__set_defaultResultSetHoldabilityHoldCursorsOverCommit(const bool val) {
  this->defaultResultSetHoldabilityHoldCursorsOverCommit = val;
}

void ServiceMetaData::__set_sqlStateIsXOpen(const bool val) {
  this->sqlStateIsXOpen = val;
}

void ServiceMetaData::__set_catalogAtStart(const bool val) {
  this->catalogAtStart = val;
}

void ServiceMetaData::__set_transactionDefaults(const std::map<TransactionAttribute::type, bool> & val) {
  this->transactionDefaults = val;
}

void ServiceMetaData::__set_rowIdLifeTime(const RowIdLifetime::type val) {
  this->rowIdLifeTime = val;
}

void ServiceMetaData::__set_supportedFeatures(const std::set<ServiceFeature::type> & val) {
  this->supportedFeatures = val;
}

void ServiceMetaData::__set_featuresWithParams(const std::map<ServiceFeatureParameterized::type, std::vector<int32_t> > & val) {
  this->featuresWithParams = val;
}

uint32_t ServiceMetaData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_productName = false;
  bool isset_productVersion = false;
  bool isset_productMajorVersion = false;
  bool isset_productMinorVersion = false;
  bool isset_jdbcMajorVersion = false;
  bool isset_jdbcMinorVersion = false;
  bool isset_identifierQuote = false;
  bool isset_sqlKeywords = false;
  bool isset_numericFunctions = false;
  bool isset_stringFunctions = false;
  bool isset_systemFunctions = false;
  bool isset_dateTimeFunctions = false;
  bool isset_searchStringEscape = false;
  bool isset_supportedCONVERT = false;
  bool isset_schemaTerm = false;
  bool isset_procedureTerm = false;
  bool isset_catalogTerm = false;
  bool isset_catalogSeparator = false;
  bool isset_maxBinaryLiteralLength = false;
  bool isset_maxCharLiteralLength = false;
  bool isset_maxColumnsInGroupBy = false;
  bool isset_maxColumnsInIndex = false;
  bool isset_maxColumnsInOrderBy = false;
  bool isset_maxColumnsInSelect = false;
  bool isset_maxColumnsInTable = false;
  bool isset_maxConnections = false;
  bool isset_maxIndexLength = false;
  bool isset_maxRowSize = false;
  bool isset_maxStatementLength = false;
  bool isset_maxOpenStatements = false;
  bool isset_maxTableNamesInSelect = false;
  bool isset_maxColumnNameLength = false;
  bool isset_maxCursorNameLength = false;
  bool isset_maxSchemaNameLength = false;
  bool isset_maxProcedureNameLength = false;
  bool isset_maxCatalogNameLength = false;
  bool isset_maxTableNameLength = false;
  bool isset_maxUserNameLength = false;
  bool isset_defaultTransactionIsolation = false;
  bool isset_defaultResultSetType = false;
  bool isset_defaultResultSetHoldabilityHoldCursorsOverCommit = false;
  bool isset_sqlStateIsXOpen = false;
  bool isset_catalogAtStart = false;
  bool isset_transactionDefaults = false;
  bool isset_rowIdLifeTime = false;
  bool isset_supportedFeatures = false;
  bool isset_featuresWithParams = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productName);
          isset_productName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->productVersion);
          isset_productVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->productMajorVersion);
          isset_productMajorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->productMinorVersion);
          isset_productMinorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->jdbcMajorVersion);
          isset_jdbcMajorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->jdbcMinorVersion);
          isset_jdbcMinorVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identifierQuote);
          isset_identifierQuote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sqlKeywords.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->sqlKeywords.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readString(this->sqlKeywords[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sqlKeywords = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->numericFunctions.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->numericFunctions.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readString(this->numericFunctions[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          isset_numericFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stringFunctions.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->stringFunctions.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += iprot->readString(this->stringFunctions[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          isset_stringFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->systemFunctions.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->systemFunctions.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += iprot->readString(this->systemFunctions[_i35]);
            }
            xfer += iprot->readListEnd();
          }
          isset_systemFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dateTimeFunctions.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->dateTimeFunctions.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readString(this->dateTimeFunctions[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          isset_dateTimeFunctions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->searchStringEscape);
          isset_searchStringEscape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->extraNameCharacters);
          this->__isset.extraNameCharacters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->supportedCONVERT.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _ktype42;
            ::apache::thrift::protocol::TType _vtype43;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              SnappyType::type _key46;
              int32_t ecast48;
              xfer += iprot->readI32(ecast48);
              _key46 = (SnappyType::type)ecast48;
              std::set<SnappyType::type> & _val47 = this->supportedCONVERT[_key46];
              {
                _val47.clear();
                uint32_t _size49;
                ::apache::thrift::protocol::TType _etype52;
                xfer += iprot->readSetBegin(_etype52, _size49);
                uint32_t _i53;
                for (_i53 = 0; _i53 < _size49; ++_i53)
                {
                  SnappyType::type _elem54;
                  int32_t ecast55;
                  xfer += iprot->readI32(ecast55);
                  _elem54 = (SnappyType::type)ecast55;
                  _val47.insert(_elem54);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_supportedCONVERT = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaTerm);
          isset_schemaTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->procedureTerm);
          isset_procedureTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogTerm);
          isset_catalogTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogSeparator);
          isset_catalogSeparator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxBinaryLiteralLength);
          isset_maxBinaryLiteralLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCharLiteralLength);
          isset_maxCharLiteralLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInGroupBy);
          isset_maxColumnsInGroupBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInIndex);
          isset_maxColumnsInIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInOrderBy);
          isset_maxColumnsInOrderBy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInSelect);
          isset_maxColumnsInSelect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnsInTable);
          isset_maxColumnsInTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxConnections);
          isset_maxConnections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxIndexLength);
          isset_maxIndexLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxRowSize);
          isset_maxRowSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxStatementLength);
          isset_maxStatementLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxOpenStatements);
          isset_maxOpenStatements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxTableNamesInSelect);
          isset_maxTableNamesInSelect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxColumnNameLength);
          isset_maxColumnNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCursorNameLength);
          isset_maxCursorNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxSchemaNameLength);
          isset_maxSchemaNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxProcedureNameLength);
          isset_maxProcedureNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCatalogNameLength);
          isset_maxCatalogNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxTableNameLength);
          isset_maxTableNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxUserNameLength);
          isset_maxUserNameLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->defaultTransactionIsolation);
          isset_defaultTransactionIsolation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->defaultResultSetType);
          isset_defaultResultSetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->defaultResultSetHoldabilityHoldCursorsOverCommit);
          isset_defaultResultSetHoldabilityHoldCursorsOverCommit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 43:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sqlStateIsXOpen);
          isset_sqlStateIsXOpen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 44:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->catalogAtStart);
          isset_catalogAtStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 45:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->transactionDefaults.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _ktype57;
            ::apache::thrift::protocol::TType _vtype58;
            xfer += iprot->readMapBegin(_ktype57, _vtype58, _size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              TransactionAttribute::type _key61;
              int32_t ecast63;
              xfer += iprot->readI32(ecast63);
              _key61 = (TransactionAttribute::type)ecast63;
              bool& _val62 = this->transactionDefaults[_key61];
              xfer += iprot->readBool(_val62);
            }
            xfer += iprot->readMapEnd();
          }
          isset_transactionDefaults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 46:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->rowIdLifeTime = (RowIdLifetime::type)ecast64;
          isset_rowIdLifeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 47:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->supportedFeatures.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readSetBegin(_etype68, _size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              ServiceFeature::type _elem70;
              int32_t ecast71;
              xfer += iprot->readI32(ecast71);
              _elem70 = (ServiceFeature::type)ecast71;
              this->supportedFeatures.insert(_elem70);
            }
            xfer += iprot->readSetEnd();
          }
          isset_supportedFeatures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 48:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->featuresWithParams.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _ktype73;
            ::apache::thrift::protocol::TType _vtype74;
            xfer += iprot->readMapBegin(_ktype73, _vtype74, _size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              ServiceFeatureParameterized::type _key77;
              int32_t ecast79;
              xfer += iprot->readI32(ecast79);
              _key77 = (ServiceFeatureParameterized::type)ecast79;
              std::vector<int32_t> & _val78 = this->featuresWithParams[_key77];
              {
                _val78.clear();
                uint32_t _size80;
                ::apache::thrift::protocol::TType _etype83;
                xfer += iprot->readListBegin(_etype83, _size80);
                _val78.resize(_size80);
                uint32_t _i84;
                for (_i84 = 0; _i84 < _size80; ++_i84)
                {
                  xfer += iprot->readI32(_val78[_i84]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_featuresWithParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_productName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productMajorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_productMinorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_jdbcMajorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_jdbcMinorVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_identifierQuote)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sqlKeywords)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numericFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_stringFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_systemFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dateTimeFunctions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_searchStringEscape)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedCONVERT)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schemaTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_procedureTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogTerm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogSeparator)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxBinaryLiteralLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCharLiteralLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInGroupBy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInIndex)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInOrderBy)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInSelect)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnsInTable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxConnections)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxIndexLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxRowSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxStatementLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxOpenStatements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxTableNamesInSelect)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxColumnNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCursorNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxSchemaNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxProcedureNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxCatalogNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxTableNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxUserNameLength)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultTransactionIsolation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultResultSetType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultResultSetHoldabilityHoldCursorsOverCommit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sqlStateIsXOpen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalogAtStart)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_transactionDefaults)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rowIdLifeTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedFeatures)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_featuresWithParams)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServiceMetaData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServiceMetaData");

  xfer += oprot->writeFieldBegin("productName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->productName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productVersion", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->productVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productMajorVersion", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->productMajorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("productMinorVersion", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->productMinorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jdbcMajorVersion", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->jdbcMajorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jdbcMinorVersion", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->jdbcMinorVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("identifierQuote", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->identifierQuote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqlKeywords", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sqlKeywords.size()));
    std::vector<std::string> ::const_iterator _iter85;
    for (_iter85 = this->sqlKeywords.begin(); _iter85 != this->sqlKeywords.end(); ++_iter85)
    {
      xfer += oprot->writeString((*_iter85));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numericFunctions", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->numericFunctions.size()));
    std::vector<std::string> ::const_iterator _iter86;
    for (_iter86 = this->numericFunctions.begin(); _iter86 != this->numericFunctions.end(); ++_iter86)
    {
      xfer += oprot->writeString((*_iter86));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stringFunctions", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->stringFunctions.size()));
    std::vector<std::string> ::const_iterator _iter87;
    for (_iter87 = this->stringFunctions.begin(); _iter87 != this->stringFunctions.end(); ++_iter87)
    {
      xfer += oprot->writeString((*_iter87));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("systemFunctions", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->systemFunctions.size()));
    std::vector<std::string> ::const_iterator _iter88;
    for (_iter88 = this->systemFunctions.begin(); _iter88 != this->systemFunctions.end(); ++_iter88)
    {
      xfer += oprot->writeString((*_iter88));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dateTimeFunctions", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dateTimeFunctions.size()));
    std::vector<std::string> ::const_iterator _iter89;
    for (_iter89 = this->dateTimeFunctions.begin(); _iter89 != this->dateTimeFunctions.end(); ++_iter89)
    {
      xfer += oprot->writeString((*_iter89));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("searchStringEscape", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->searchStringEscape);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.extraNameCharacters) {
    xfer += oprot->writeFieldBegin("extraNameCharacters", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->extraNameCharacters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("supportedCONVERT", ::apache::thrift::protocol::T_MAP, 15);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->supportedCONVERT.size()));
    std::map<SnappyType::type, std::set<SnappyType::type> > ::const_iterator _iter90;
    for (_iter90 = this->supportedCONVERT.begin(); _iter90 != this->supportedCONVERT.end(); ++_iter90)
    {
      xfer += oprot->writeI32((int32_t)_iter90->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter90->second.size()));
        std::set<SnappyType::type> ::const_iterator _iter91;
        for (_iter91 = _iter90->second.begin(); _iter91 != _iter90->second.end(); ++_iter91)
        {
          xfer += oprot->writeI32((int32_t)(*_iter91));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaTerm", ::apache::thrift::protocol::T_STRING, 16);
  xfer += oprot->writeString(this->schemaTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("procedureTerm", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->procedureTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogTerm", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->catalogTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogSeparator", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->catalogSeparator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxBinaryLiteralLength", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->maxBinaryLiteralLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCharLiteralLength", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->maxCharLiteralLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInGroupBy", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->maxColumnsInGroupBy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInIndex", ::apache::thrift::protocol::T_I32, 23);
  xfer += oprot->writeI32(this->maxColumnsInIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInOrderBy", ::apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->maxColumnsInOrderBy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInSelect", ::apache::thrift::protocol::T_I32, 25);
  xfer += oprot->writeI32(this->maxColumnsInSelect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnsInTable", ::apache::thrift::protocol::T_I32, 26);
  xfer += oprot->writeI32(this->maxColumnsInTable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxConnections", ::apache::thrift::protocol::T_I32, 27);
  xfer += oprot->writeI32(this->maxConnections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxIndexLength", ::apache::thrift::protocol::T_I32, 28);
  xfer += oprot->writeI32(this->maxIndexLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxRowSize", ::apache::thrift::protocol::T_I32, 29);
  xfer += oprot->writeI32(this->maxRowSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxStatementLength", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->maxStatementLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxOpenStatements", ::apache::thrift::protocol::T_I32, 31);
  xfer += oprot->writeI32(this->maxOpenStatements);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxTableNamesInSelect", ::apache::thrift::protocol::T_I32, 32);
  xfer += oprot->writeI32(this->maxTableNamesInSelect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxColumnNameLength", ::apache::thrift::protocol::T_I32, 33);
  xfer += oprot->writeI32(this->maxColumnNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCursorNameLength", ::apache::thrift::protocol::T_I32, 34);
  xfer += oprot->writeI32(this->maxCursorNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxSchemaNameLength", ::apache::thrift::protocol::T_I32, 35);
  xfer += oprot->writeI32(this->maxSchemaNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxProcedureNameLength", ::apache::thrift::protocol::T_I32, 36);
  xfer += oprot->writeI32(this->maxProcedureNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCatalogNameLength", ::apache::thrift::protocol::T_I32, 37);
  xfer += oprot->writeI32(this->maxCatalogNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxTableNameLength", ::apache::thrift::protocol::T_I32, 38);
  xfer += oprot->writeI32(this->maxTableNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxUserNameLength", ::apache::thrift::protocol::T_I32, 39);
  xfer += oprot->writeI32(this->maxUserNameLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultTransactionIsolation", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->defaultTransactionIsolation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultResultSetType", ::apache::thrift::protocol::T_BYTE, 41);
  xfer += oprot->writeByte(this->defaultResultSetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultResultSetHoldabilityHoldCursorsOverCommit", ::apache::thrift::protocol::T_BOOL, 42);
  xfer += oprot->writeBool(this->defaultResultSetHoldabilityHoldCursorsOverCommit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqlStateIsXOpen", ::apache::thrift::protocol::T_BOOL, 43);
  xfer += oprot->writeBool(this->sqlStateIsXOpen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalogAtStart", ::apache::thrift::protocol::T_BOOL, 44);
  xfer += oprot->writeBool(this->catalogAtStart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transactionDefaults", ::apache::thrift::protocol::T_MAP, 45);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->transactionDefaults.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter92;
    for (_iter92 = this->transactionDefaults.begin(); _iter92 != this->transactionDefaults.end(); ++_iter92)
    {
      xfer += oprot->writeI32((int32_t)_iter92->first);
      xfer += oprot->writeBool(_iter92->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rowIdLifeTime", ::apache::thrift::protocol::T_I32, 46);
  xfer += oprot->writeI32((int32_t)this->rowIdLifeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("supportedFeatures", ::apache::thrift::protocol::T_SET, 47);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->supportedFeatures.size()));
    std::set<ServiceFeature::type> ::const_iterator _iter93;
    for (_iter93 = this->supportedFeatures.begin(); _iter93 != this->supportedFeatures.end(); ++_iter93)
    {
      xfer += oprot->writeI32((int32_t)(*_iter93));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("featuresWithParams", ::apache::thrift::protocol::T_MAP, 48);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->featuresWithParams.size()));
    std::map<ServiceFeatureParameterized::type, std::vector<int32_t> > ::const_iterator _iter94;
    for (_iter94 = this->featuresWithParams.begin(); _iter94 != this->featuresWithParams.end(); ++_iter94)
    {
      xfer += oprot->writeI32((int32_t)_iter94->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter94->second.size()));
        std::vector<int32_t> ::const_iterator _iter95;
        for (_iter95 = _iter94->second.begin(); _iter95 != _iter94->second.end(); ++_iter95)
        {
          xfer += oprot->writeI32((*_iter95));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceMetaData &a, ServiceMetaData &b) noexcept {
  using ::std::swap;
  static_assert(noexcept(swap(a, b)), "throwing swap");
  swap(a.productName, b.productName);
  swap(a.productVersion, b.productVersion);
  swap(a.productMajorVersion, b.productMajorVersion);
  swap(a.productMinorVersion, b.productMinorVersion);
  swap(a.jdbcMajorVersion, b.jdbcMajorVersion);
  swap(a.jdbcMinorVersion, b.jdbcMinorVersion);
  swap(a.identifierQuote, b.identifierQuote);
  swap(a.sqlKeywords, b.sqlKeywords);
  swap(a.numericFunctions, b.numericFunctions);
  swap(a.stringFunctions, b.stringFunctions);
  swap(a.systemFunctions, b.systemFunctions);
  swap(a.dateTimeFunctions, b.dateTimeFunctions);
  swap(a.searchStringEscape, b.searchStringEscape);
  swap(a.extraNameCharacters, b.extraNameCharacters);
  swap(a.supportedCONVERT, b.supportedCONVERT);
  swap(a.schemaTerm, b.schemaTerm);
  swap(a.procedureTerm, b.procedureTerm);
  swap(a.catalogTerm, b.catalogTerm);
  swap(a.catalogSeparator, b.catalogSeparator);
  swap(a.maxBinaryLiteralLength, b.maxBinaryLiteralLength);
  swap(a.maxCharLiteralLength, b.maxCharLiteralLength);
  swap(a.maxColumnsInGroupBy, b.maxColumnsInGroupBy);
  swap(a.maxColumnsInIndex, b.maxColumnsInIndex);
  swap(a.maxColumnsInOrderBy, b.maxColumnsInOrderBy);
  swap(a.maxColumnsInSelect, b.maxColumnsInSelect);
  swap(a.maxColumnsInTable, b.maxColumnsInTable);
  swap(a.maxConnections, b.maxConnections);
  swap(a.maxIndexLength, b.maxIndexLength);
  swap(a.maxRowSize, b.maxRowSize);
  swap(a.maxStatementLength, b.maxStatementLength);
  swap(a.maxOpenStatements, b.maxOpenStatements);
  swap(a.maxTableNamesInSelect, b.maxTableNamesInSelect);
  swap(a.maxColumnNameLength, b.maxColumnNameLength);
  swap(a.maxCursorNameLength, b.maxCursorNameLength);
  swap(a.maxSchemaNameLength, b.maxSchemaNameLength);
  swap(a.maxProcedureNameLength, b.maxProcedureNameLength);
  swap(a.maxCatalogNameLength, b.maxCatalogNameLength);
  swap(a.maxTableNameLength, b.maxTableNameLength);
  swap(a.maxUserNameLength, b.maxUserNameLength);
  swap(a.defaultTransactionIsolation, b.defaultTransactionIsolation);
  swap(a.defaultResultSetType, b.defaultResultSetType);
  swap(a.defaultResultSetHoldabilityHoldCursorsOverCommit, b.defaultResultSetHoldabilityHoldCursorsOverCommit);
  swap(a.sqlStateIsXOpen, b.sqlStateIsXOpen);
  swap(a.catalogAtStart, b.catalogAtStart);
  swap(a.transactionDefaults, b.transactionDefaults);
  swap(a.rowIdLifeTime, b.rowIdLifeTime);
  swap(a.supportedFeatures, b.supportedFeatures);
  swap(a.featuresWithParams, b.featuresWithParams);
  swap(a.__isset, b.__isset);
}

ServiceMetaData::ServiceMetaData(const ServiceMetaData& other96) {
  productName = other96.productName;
  productVersion = other96.productVersion;
  productMajorVersion = other96.productMajorVersion;
  productMinorVersion = other96.productMinorVersion;
  jdbcMajorVersion = other96.jdbcMajorVersion;
  jdbcMinorVersion = other96.jdbcMinorVersion;
  identifierQuote = other96.identifierQuote;
  sqlKeywords = other96.sqlKeywords;
  numericFunctions = other96.numericFunctions;
  stringFunctions = other96.stringFunctions;
  systemFunctions = other96.systemFunctions;
  dateTimeFunctions = other96.dateTimeFunctions;
  searchStringEscape = other96.searchStringEscape;
  extraNameCharacters = other96.extraNameCharacters;
  supportedCONVERT = other96.supportedCONVERT;
  schemaTerm = other96.schemaTerm;
  procedureTerm = other96.procedureTerm;
  catalogTerm = other96.catalogTerm;
  catalogSeparator = other96.catalogSeparator;
  maxBinaryLiteralLength = other96.maxBinaryLiteralLength;
  maxCharLiteralLength = other96.maxCharLiteralLength;
  maxColumnsInGroupBy = other96.maxColumnsInGroupBy;
  maxColumnsInIndex = other96.maxColumnsInIndex;
  maxColumnsInOrderBy = other96.maxColumnsInOrderBy;
  maxColumnsInSelect = other96.maxColumnsInSelect;
  maxColumnsInTable = other96.maxColumnsInTable;
  maxConnections = other96.maxConnections;
  maxIndexLength = other96.maxIndexLength;
  maxRowSize = other96.maxRowSize;
  maxStatementLength = other96.maxStatementLength;
  maxOpenStatements = other96.maxOpenStatements;
  maxTableNamesInSelect = other96.maxTableNamesInSelect;
  maxColumnNameLength = other96.maxColumnNameLength;
  maxCursorNameLength = other96.maxCursorNameLength;
  maxSchemaNameLength = other96.maxSchemaNameLength;
  maxProcedureNameLength = other96.maxProcedureNameLength;
  maxCatalogNameLength = other96.maxCatalogNameLength;
  maxTableNameLength = other96.maxTableNameLength;
  maxUserNameLength = other96.maxUserNameLength;
  defaultTransactionIsolation = other96.defaultTransactionIsolation;
  defaultResultSetType = other96.defaultResultSetType;
  defaultResultSetHoldabilityHoldCursorsOverCommit = other96.defaultResultSetHoldabilityHoldCursorsOverCommit;
  sqlStateIsXOpen = other96.sqlStateIsXOpen;
  catalogAtStart = other96.catalogAtStart;
  transactionDefaults = other96.transactionDefaults;
  rowIdLifeTime = other96.rowIdLifeTime;
  supportedFeatures = other96.supportedFeatures;
  featuresWithParams = other96.featuresWithParams;
  __isset = other96.__isset;
}
ServiceMetaData::ServiceMetaData( ServiceMetaData&& other97) noexcept {
  productName = std::move(other97.productName);
  productVersion = std::move(other97.productVersion);
  productMajorVersion = std::move(other97.productMajorVersion);
  productMinorVersion = std::move(other97.productMinorVersion);
  jdbcMajorVersion = std::move(other97.jdbcMajorVersion);
  jdbcMinorVersion = std::move(other97.jdbcMinorVersion);
  identifierQuote = std::move(other97.identifierQuote);
  sqlKeywords = std::move(other97.sqlKeywords);
  numericFunctions = std::move(other97.numericFunctions);
  stringFunctions = std::move(other97.stringFunctions);
  systemFunctions = std::move(other97.systemFunctions);
  dateTimeFunctions = std::move(other97.dateTimeFunctions);
  searchStringEscape = std::move(other97.searchStringEscape);
  extraNameCharacters = std::move(other97.extraNameCharacters);
  supportedCONVERT = std::move(other97.supportedCONVERT);
  schemaTerm = std::move(other97.schemaTerm);
  procedureTerm = std::move(other97.procedureTerm);
  catalogTerm = std::move(other97.catalogTerm);
  catalogSeparator = std::move(other97.catalogSeparator);
  maxBinaryLiteralLength = std::move(other97.maxBinaryLiteralLength);
  maxCharLiteralLength = std::move(other97.maxCharLiteralLength);
  maxColumnsInGroupBy = std::move(other97.maxColumnsInGroupBy);
  maxColumnsInIndex = std::move(other97.maxColumnsInIndex);
  maxColumnsInOrderBy = std::move(other97.maxColumnsInOrderBy);
  maxColumnsInSelect = std::move(other97.maxColumnsInSelect);
  maxColumnsInTable = std::move(other97.maxColumnsInTable);
  maxConnections = std::move(other97.maxConnections);
  maxIndexLength = std::move(other97.maxIndexLength);
  maxRowSize = std::move(other97.maxRowSize);
  maxStatementLength = std::move(other97.maxStatementLength);
  maxOpenStatements = std::move(other97.maxOpenStatements);
  maxTableNamesInSelect = std::move(other97.maxTableNamesInSelect);
  maxColumnNameLength = std::move(other97.maxColumnNameLength);
  maxCursorNameLength = std::move(other97.maxCursorNameLength);
  maxSchemaNameLength = std::move(other97.maxSchemaNameLength);
  maxProcedureNameLength = std::move(other97.maxProcedureNameLength);
  maxCatalogNameLength = std::move(other97.maxCatalogNameLength);
  maxTableNameLength = std::move(other97.maxTableNameLength);
  maxUserNameLength = std::move(other97.maxUserNameLength);
  defaultTransactionIsolation = std::move(other97.defaultTransactionIsolation);
  defaultResultSetType = std::move(other97.defaultResultSetType);
  defaultResultSetHoldabilityHoldCursorsOverCommit = std::move(other97.defaultResultSetHoldabilityHoldCursorsOverCommit);
  sqlStateIsXOpen = std::move(other97.sqlStateIsXOpen);
  catalogAtStart = std::move(other97.catalogAtStart);
  transactionDefaults = std::move(other97.transactionDefaults);
  rowIdLifeTime = std::move(other97.rowIdLifeTime);
  supportedFeatures = std::move(other97.supportedFeatures);
  featuresWithParams = std::move(other97.featuresWithParams);
  __isset = std::move(other97.__isset);
}
ServiceMetaData& ServiceMetaData::operator=(const ServiceMetaData& other98) {
  productName = other98.productName;
  productVersion = other98.productVersion;
  productMajorVersion = other98.productMajorVersion;
  productMinorVersion = other98.productMinorVersion;
  jdbcMajorVersion = other98.jdbcMajorVersion;
  jdbcMinorVersion = other98.jdbcMinorVersion;
  identifierQuote = other98.identifierQuote;
  sqlKeywords = other98.sqlKeywords;
  numericFunctions = other98.numericFunctions;
  stringFunctions = other98.stringFunctions;
  systemFunctions = other98.systemFunctions;
  dateTimeFunctions = other98.dateTimeFunctions;
  searchStringEscape = other98.searchStringEscape;
  extraNameCharacters = other98.extraNameCharacters;
  supportedCONVERT = other98.supportedCONVERT;
  schemaTerm = other98.schemaTerm;
  procedureTerm = other98.procedureTerm;
  catalogTerm = other98.catalogTerm;
  catalogSeparator = other98.catalogSeparator;
  maxBinaryLiteralLength = other98.maxBinaryLiteralLength;
  maxCharLiteralLength = other98.maxCharLiteralLength;
  maxColumnsInGroupBy = other98.maxColumnsInGroupBy;
  maxColumnsInIndex = other98.maxColumnsInIndex;
  maxColumnsInOrderBy = other98.maxColumnsInOrderBy;
  maxColumnsInSelect = other98.maxColumnsInSelect;
  maxColumnsInTable = other98.maxColumnsInTable;
  maxConnections = other98.maxConnections;
  maxIndexLength = other98.maxIndexLength;
  maxRowSize = other98.maxRowSize;
  maxStatementLength = other98.maxStatementLength;
  maxOpenStatements = other98.maxOpenStatements;
  maxTableNamesInSelect = other98.maxTableNamesInSelect;
  maxColumnNameLength = other98.maxColumnNameLength;
  maxCursorNameLength = other98.maxCursorNameLength;
  maxSchemaNameLength = other98.maxSchemaNameLength;
  maxProcedureNameLength = other98.maxProcedureNameLength;
  maxCatalogNameLength = other98.maxCatalogNameLength;
  maxTableNameLength = other98.maxTableNameLength;
  maxUserNameLength = other98.maxUserNameLength;
  defaultTransactionIsolation = other98.defaultTransactionIsolation;
  defaultResultSetType = other98.defaultResultSetType;
  defaultResultSetHoldabilityHoldCursorsOverCommit = other98.defaultResultSetHoldabilityHoldCursorsOverCommit;
  sqlStateIsXOpen = other98.sqlStateIsXOpen;
  catalogAtStart = other98.catalogAtStart;
  transactionDefaults = other98.transactionDefaults;
  rowIdLifeTime = other98.rowIdLifeTime;
  supportedFeatures = other98.supportedFeatures;
  featuresWithParams = other98.featuresWithParams;
  __isset = other98.__isset;
  return *this;
}
ServiceMetaData& ServiceMetaData::operator=(ServiceMetaData&& other99) noexcept {
  productName = std::move(other99.productName);
  productVersion = std::move(other99.productVersion);
  productMajorVersion = std::move(other99.productMajorVersion);
  productMinorVersion = std::move(other99.productMinorVersion);
  jdbcMajorVersion = std::move(other99.jdbcMajorVersion);
  jdbcMinorVersion = std::move(other99.jdbcMinorVersion);
  identifierQuote = std::move(other99.identifierQuote);
  sqlKeywords = std::move(other99.sqlKeywords);
  numericFunctions = std::move(other99.numericFunctions);
  stringFunctions = std::move(other99.stringFunctions);
  systemFunctions = std::move(other99.systemFunctions);
  dateTimeFunctions = std::move(other99.dateTimeFunctions);
  searchStringEscape = std::move(other99.searchStringEscape);
  extraNameCharacters = std::move(other99.extraNameCharacters);
  supportedCONVERT = std::move(other99.supportedCONVERT);
  schemaTerm = std::move(other99.schemaTerm);
  procedureTerm = std::move(other99.procedureTerm);
  catalogTerm = std::move(other99.catalogTerm);
  catalogSeparator = std::move(other99.catalogSeparator);
  maxBinaryLiteralLength = std::move(other99.maxBinaryLiteralLength);
  maxCharLiteralLength = std::move(other99.maxCharLiteralLength);
  maxColumnsInGroupBy = std::move(other99.maxColumnsInGroupBy);
  maxColumnsInIndex = std::move(other99.maxColumnsInIndex);
  maxColumnsInOrderBy = std::move(other99.maxColumnsInOrderBy);
  maxColumnsInSelect = std::move(other99.maxColumnsInSelect);
  maxColumnsInTable = std::move(other99.maxColumnsInTable);
  maxConnections = std::move(other99.maxConnections);
  maxIndexLength = std::move(other99.maxIndexLength);
  maxRowSize = std::move(other99.maxRowSize);
  maxStatementLength = std::move(other99.maxStatementLength);
  maxOpenStatements = std::move(other99.maxOpenStatements);
  maxTableNamesInSelect = std::move(other99.maxTableNamesInSelect);
  maxColumnNameLength = std::move(other99.maxColumnNameLength);
  maxCursorNameLength = std::move(other99.maxCursorNameLength);
  maxSchemaNameLength = std::move(other99.maxSchemaNameLength);
  maxProcedureNameLength = std::move(other99.maxProcedureNameLength);
  maxCatalogNameLength = std::move(other99.maxCatalogNameLength);
  maxTableNameLength = std::move(other99.maxTableNameLength);
  maxUserNameLength = std::move(other99.maxUserNameLength);
  defaultTransactionIsolation = std::move(other99.defaultTransactionIsolation);
  defaultResultSetType = std::move(other99.defaultResultSetType);
  defaultResultSetHoldabilityHoldCursorsOverCommit = std::move(other99.defaultResultSetHoldabilityHoldCursorsOverCommit);
  sqlStateIsXOpen = std::move(other99.sqlStateIsXOpen);
  catalogAtStart = std::move(other99.catalogAtStart);
  transactionDefaults = std::move(other99.transactionDefaults);
  rowIdLifeTime = std::move(other99.rowIdLifeTime);
  supportedFeatures = std::move(other99.supportedFeatures);
  featuresWithParams = std::move(other99.featuresWithParams);
  __isset = std::move(other99.__isset);
  return *this;
}
void ServiceMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServiceMetaData(";
  out << "productName=" << to_string(productName);
  out << ", " << "productVersion=" << to_string(productVersion);
  out << ", " << "productMajorVersion=" << to_string(productMajorVersion);
  out << ", " << "productMinorVersion=" << to_string(productMinorVersion);
  out << ", " << "jdbcMajorVersion=" << to_string(jdbcMajorVersion);
  out << ", " << "jdbcMinorVersion=" << to_string(jdbcMinorVersion);
  out << ", " << "identifierQuote=" << to_string(identifierQuote);
  out << ", " << "sqlKeywords=" << to_string(sqlKeywords);
  out << ", " << "numericFunctions=" << to_string(numericFunctions);
  out << ", " << "stringFunctions=" << to_string(stringFunctions);
  out << ", " << "systemFunctions=" << to_string(systemFunctions);
  out << ", " << "dateTimeFunctions=" << to_string(dateTimeFunctions);
  out << ", " << "searchStringEscape=" << to_string(searchStringEscape);
  out << ", " << "extraNameCharacters="; (__isset.extraNameCharacters ? (out << to_string(extraNameCharacters)) : (out << "<null>"));
  out << ", " << "supportedCONVERT=" << to_string(supportedCONVERT);
  out << ", " << "schemaTerm=" << to_string(schemaTerm);
  out << ", " << "procedureTerm=" << to_string(procedureTerm);
  out << ", " << "catalogTerm=" << to_string(catalogTerm);
  out << ", " << "catalogSeparator=" << to_string(catalogSeparator);
  out << ", " << "maxBinaryLiteralLength=" << to_string(maxBinaryLiteralLength);
  out << ", " << "maxCharLiteralLength=" << to_string(maxCharLiteralLength);
  out << ", " << "maxColumnsInGroupBy=" << to_string(maxColumnsInGroupBy);
  out << ", " << "maxColumnsInIndex=" << to_string(maxColumnsInIndex);
  out << ", " << "maxColumnsInOrderBy=" << to_string(maxColumnsInOrderBy);
  out << ", " << "maxColumnsInSelect=" << to_string(maxColumnsInSelect);
  out << ", " << "maxColumnsInTable=" << to_string(maxColumnsInTable);
  out << ", " << "maxConnections=" << to_string(maxConnections);
  out << ", " << "maxIndexLength=" << to_string(maxIndexLength);
  out << ", " << "maxRowSize=" << to_string(maxRowSize);
  out << ", " << "maxStatementLength=" << to_string(maxStatementLength);
  out << ", " << "maxOpenStatements=" << to_string(maxOpenStatements);
  out << ", " << "maxTableNamesInSelect=" << to_string(maxTableNamesInSelect);
  out << ", " << "maxColumnNameLength=" << to_string(maxColumnNameLength);
  out << ", " << "maxCursorNameLength=" << to_string(maxCursorNameLength);
  out << ", " << "maxSchemaNameLength=" << to_string(maxSchemaNameLength);
  out << ", " << "maxProcedureNameLength=" << to_string(maxProcedureNameLength);
  out << ", " << "maxCatalogNameLength=" << to_string(maxCatalogNameLength);
  out << ", " << "maxTableNameLength=" << to_string(maxTableNameLength);
  out << ", " << "maxUserNameLength=" << to_string(maxUserNameLength);
  out << ", " << "defaultTransactionIsolation=" << to_string(defaultTransactionIsolation);
  out << ", " << "defaultResultSetType=" << to_string(defaultResultSetType);
  out << ", " << "defaultResultSetHoldabilityHoldCursorsOverCommit=" << to_string(defaultResultSetHoldabilityHoldCursorsOverCommit);
  out << ", " << "sqlStateIsXOpen=" << to_string(sqlStateIsXOpen);
  out << ", " << "catalogAtStart=" << to_string(catalogAtStart);
  out << ", " << "transactionDefaults=" << to_string(transactionDefaults);
  out << ", " << "rowIdLifeTime=" << to_string(rowIdLifeTime);
  out << ", " << "supportedFeatures=" << to_string(supportedFeatures);
  out << ", " << "featuresWithParams=" << to_string(featuresWithParams);
  out << ")";
}

}}} // namespace
